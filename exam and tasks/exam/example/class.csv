f.sort_values *сортировка
fillna(0)   *Замінює пропущені значення на задане (0)
anime.head(3) *показать начало таблицы
rating.tail(1) *конец таблицы
len(ratings['user_id'].unique()) *уникальные значения в столбце
len(df) *кол-во строк
anime.columns.tolist() *столбцы
.value_counts() *колличество значений
.sum() *сумма значений
anime['train set'] = True *добавить столбец
anime.drop(['anime_id', 'genre', 'members'], axis=1).head() *удалить столбец

*общая сумма значений
 df = pd.DataFrame([[1,'Bob', 8000],
                   [2,'Sally', 9000],
                   [3,'Scott', 20]], columns=['id','name', 'power level'])
 df.append(df.sum(axis=0), ignore_index=True)

*объединить датафреймы 
 df1 = anime[0:2]
 df2 = anime[2:4]
 pd.concat([df1, df2], ignore_index=True)

*сгруппировать и получить колличество значений
anime.groupby('type').count() або 
anime.groupby('type').value_count()


*группировка по дате виджеты
start_date_widget = widgets.DatePicker(description='Початкова дата', value=pd.to_datetime(merge_df['date'].min()))
end_date_widget = widgets.DatePicker(description='Кінцева дата', value=pd.to_datetime(merge_df['date'].max()))
display(start_date_widget, end_date_widget)

merge_df['date'] = pd.to_datetime(merge_df['date'])
filtered_df = merge_df[(merge_df['date'] >= start_date_widget.value) & (merge_df['date'] <= end_date_widget.value)]

earnings_by_department = filtered_df.groupby('name_viddil').agg({'hours': 'sum', 'likar_price': 'mean'}).reset_index()
earnings_by_department['total_earnings'] = earnings_by_department['hours'] * earnings_by_department['likar_price']

earnings_by_department